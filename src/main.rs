// #![allow(unused)]
// use libc::c_char;
// use std::arch::asm;
// use std::ffi::CStr;

/*

unsafe fn syscall_write(message: String) {
    asm!(
        "mov rax, 1",
        "mov rdi, 1",
        "syscall",
        in("rsi") message.as_ptr(),
        in("rdx") message.len(),
    );
}

unsafe fn syscall_uname(utsname: &utsname) {
    asm!(
        "mov rax, 63",
        "syscall",
        in("rdi") utsname as *const _,
    );
}

#[repr(C)]
pub struct utsname {
    pub sysname: [c_char; 65],
    pub nodename: [c_char; 65],
    pub release: [c_char; 65],
    pub version: [c_char; 65],
    pub machine: [c_char; 65],
    pub domainname: [c_char; 65],
}

impl utsname {
    fn new() -> Self {
        Self {
            sysname: [0; 65],
            nodename: [0; 65],
            release: [0; 65],
            version: [0; 65],
            machine: [0; 65],
            domainname: [0; 65],
        }
    }
}

#[derive(Debug)]
pub struct UnameInfo {
    pub sysname: String,
    pub nodename: String,
    pub release: String,
    pub version: String,
    pub machine: String,
    pub domainname: String,
}

// Inspired by uname crate.
impl From<utsname> for UnameInfo {
    fn from(utsname: utsname) -> Self {
        Self {
            sysname: { unsafe { CStr::from_ptr(utsname.sysname.as_ptr()) } }
                .to_string_lossy()
                .to_string(),
            nodename: { unsafe { CStr::from_ptr(utsname.nodename.as_ptr()) } }
                .to_string_lossy()
                .to_string(),
            release: { unsafe { CStr::from_ptr(utsname.release.as_ptr()) } }
                .to_string_lossy()
                .to_string(),
            version: { unsafe { CStr::from_ptr(utsname.version.as_ptr()) } }
                .to_string_lossy()
                .to_string(),
            machine: { unsafe { CStr::from_ptr(utsname.machine.as_ptr()) } }
                .to_string_lossy()
                .to_string(),
            domainname: { unsafe { CStr::from_ptr(utsname.domainname.as_ptr()) } }
                .to_string_lossy()
                .to_string(),
        }
    }
}

#[derive(Debug)]
enum Error {}

fn main() -> Result<(), Error> {
    let message1 = String::from("Hello from: ");
    let message2 = String::from("ü¶â Uggla !!!\n");
    let mut utsname = utsname::new();

    unsafe {
        syscall_write(message1);
        syscall_write(message2);
        syscall_uname(&utsname);
    }

    let uname = UnameInfo::from(utsname);
    println!("{:#?}", uname);
    Ok(())
}
*/





/*
// #![feature(asm)] // not stable on release
#![allow(unused)]
use libc::c_char;
use std::arch::asm;
use std::ffi::CStr;
use std::ffi::CString;


unsafe fn exec_asm() {
    
    // let msg = CString::new("Hello World!\n").expect("CString::new failed");
    // let msg_ptr = msg.as_ptr();

    // asm!(
    //     "mov rax, 0x02000004",   // syscall number for write() (OSX)
    //     "mov rdi, 1",            // int fd (stdout)
    //     "mov rsi, $0",           // const void* buf (message pointer)
    //     "mov rdx, $1",           // size_t count (message length)
    //     "syscall",
    //     "mov rax, 0x02000001",   // syscall number for exit() (OSX)
    //     "xor rdi, rdi",
    //     "syscall",
    //     // in(reg) msg_ptr,
    //     // in(reg) msg.to_bytes().len(),
    //     in("rsi") msg.as_ptr(),
    //     in("rdx") msg.to_bytes().len(),
    // );
    


    let msg = CString::new("Hello World!\n").expect("CString::new failed");

    asm!(
        "mov rax, 0x02000004",   // syscall number for write() (OSX)
        "mov rdi, 1",            // int fd (stdout)
        "mov rsi, {}",           // const void* buf (message pointer)
        "mov rdx, {}",           // size_t count (message length)
        "syscall",
        // "mov rax, 0x02000001",   // syscall number for exit() (OSX)
        // "xor rdi, rdi",
        // "syscall",
        in(reg) msg.as_ptr(),
        in(reg) msg.to_bytes().len(),
    );
}

fn main() {
    unsafe {
        exec_asm();
    }
}
*/




/*
    REF:    https://doc.rust-lang.org/reference/inline-assembly.html
            https://doc.rust-lang.org/rust-by-example/unsafe/asm.html

    Support for inline assembly is provided via the asm! and global_asm! macros.
    It can be used to embed handwritten assembly in the assembly output generated by the compiler.
    Support for inline assembly is stable on the following architectures:
    x86 and x86-64
    ARM
    AArch64
    RISC-V
    LoongArch
    The compiler will emit an error if asm! is used on an unsupported target.
*/


/*
use std::arch::asm;

fn main() {
    // Multiply x by 6 using shifts and adds
    let mut x: u64 = 4;
    unsafe {
        asm!(
            "mov {tmp}, {x}",    // Move the value of x into a temporary register tmp
            "shl {tmp}, 1",      // Shift tmp left by 1 (equivalent to multiplying by 2)
            "shl {x}, 2",        // Shift x left by 2 (equivalent to multiplying by 4)
            "add {x}, {tmp}",    // Add tmp to x (effectively adding x*2 to x*4)
            x = inout(reg) x,    // Declare x as an input/output operand
            tmp = out(reg) _,    // Declare tmp as an output operand
        );
    }
    assert_eq!(x, 4 * 6);        // Assert that the result is correct
    println!("{x}");             // Print the result
}
*/



// simple add operation
use std::arch::asm;

fn main() {
    let main_time: std::time::Instant = std::time::Instant::now();

    let i: u64 = 3;
    let o: u64;

    unsafe {
        asm!(
            "mov {0}, {1}",
            "add {0}, 5",
            out(reg) o,
            in(reg) i,
        );
    }
    println!("Output: {}", o);
    
    // equivalent to this code:
    // let i: u64 = 3;
    // let o: u64;
    // o = i + 5;
    // println!("Output: {}", o);


    // Multiply x by 6 using shifts and adds
    let mut x: u64 = 4;
    unsafe {
        asm!(
            "mov {tmp}, {x}",
            "shl {tmp}, 1",
            "shl {x}, 2",
            "add {x}, {tmp}",
            x = inout(reg) x,
            tmp = out(reg) _,
        );
    }
    println!("{x}");

    // End of main
    let duration: std::time::Duration = main_time.elapsed();
    let elapsed_ms: f64 = duration.as_secs_f64() * 1000.0;
    println!("\n‚åõÔ∏è Execution time: {:?} ({:?} ms)", duration, elapsed_ms);
}